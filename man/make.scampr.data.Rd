% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make.scampr.data.R
\name{make.scampr.data}
\alias{make.scampr.data}
\title{WIP}
\usage{
make.scampr.data(
  pres,
  quad,
  formula = ~1,
  coord.names = c("x", "y"),
  quad.weights.name = "quad.size",
  smallest.proportion = 0.01,
  return.model = FALSE,
  max.basis.functions,
  radius.type = c("diag", "limiting"),
  bf.matrix.type = c("sparse", "dense"),
  domain.data,
  start.nodes = 4
)
}
\arguments{
\item{pres}{a scampr model: object of class 'scampr' that provides the framework for the search algorithm. Recommended that an IPP model of the appropriate type is used.}

\item{quad}{an integer determining the rate of increasingly dense basis function configurations trialled. Default is \code{search.rate = 1}, however this can be increased to reduce computation time (at the expense of how fine-scale the search will be).}

\item{formula}{a logical indicating whether to return the model with the lowest BIC found through the search. Default is \code{FALSE}, meaning the full search results are returned.}

\item{coord.names}{a vector of character strings describing the column names of the coordinates in both data frames.}

\item{quad.weights.name}{a character string of the column name of quadrature weights in the data.}

\item{bf.matrix.type}{a character string, one of 'sparse' or 'dense' indicating whether to use sparse or dense matrix computations for the basis functions created.}

\item{domain.data}{Optional. A data frame of columns 'coord.names' that contains at least the extremities of the domain of interest. Useful to ensure the same basis function configurations are created by 'simple_basis' if comparing to various searches.}

\item{start.nodes}{an integer determining the effective number of basis functions to start the search from (\code{k = start.nodes^2} on a square domain). Default is \code{start.nodes = 4}, however this can be increased so that the search is started from a denser basis function configuration (and will likely increase computation time).}

\item{quad.size}{a numeric indicating the common quadrature size of the full quadrature points provided in \code{quad}.}
}
\value{
a data.frame with columns including- 'nodes': number used in scampr::simple_basis to create basis configuration. 'k': the number of basis functions. 'radius': the radius of the basis function configuration. 'll': the fitting marginal log-likelihood. 'BIC': the corresponding Bayesian Info. Crit. 'cpu': the computation time for the model fits. 'convergence': indicator for whether the model converged properly (0 = convergence).
}
\description{
This function takes in a scampr model and calculates likelihoods and AIC for the list of basis functions supplied. If none are supplied then the algorithm fits increasingly dense regular grids of basis functions (of the type created by scampr::simple_basis). The algorithm starts with an IPP (i.e. zero basis functions) and increases to <= 'max.basis.functions'. If 'po.fold.id' and/or 'pa.fold.id' are supplied then the function will perform a k-fold hold-one-out cross validation to calculate out-of-sample likelihoods (conditional on the latent field).
}
\examples{
#' # Get the gorilla nesting data
dat <- gorillas

# Standardise the elevation covariate
dat$elev.std <- scale(dat$elevation)

# Fit an IPP model to the point pattern
m.ipp <- scampr(pres ~ elev.std, data = dat, model.type = "ipp")
 \dontrun{
# Search through an increasingly dense regular grid of basis functions
res <- simple_basis_search(m.ipp)
}
}
