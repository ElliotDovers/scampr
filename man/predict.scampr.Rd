% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.scampr.R
\name{predict.scampr}
\alias{predict.scampr}
\title{Predict function for objects of class 'scampr'}
\usage{
\method{predict}{scampr}(
  object,
  ...,
  newdata,
  type = c("link", "response"),
  dens = c("posterior", "prior"),
  process = c("intensity", "abundance")
)
}
\arguments{
\item{object}{a scampr model object}

\item{...}{NA}

\item{newdata}{a data frame of point locations to predict over as well as predictors involved in the model}

\item{type}{a character string indicating the type of linear predictor to be returned. One of 'link' or 'response'}

\item{dens}{a character string indicating the probability density of the random effects to draw from}

\item{process}{a character string indictating the process to be estimated. One of 'intensity' or 'abundance'. Only available for combined data models.}
}
\value{
a numeric vector of length newdata (or length of fitted data) containing the predictions.
}
\description{
Functions the same as predict.glm with additional functionality. Can select whether predictions come from the realised latent field (dens = "posterior") or unrealised (dens = "prior") - depending on whether a user wants to make data specific predictions or be more broad. Particular to combined data models (popa) the user can specify whether to return the rate at which presence records occur (process = intensity) or the abundance rate (process = abundance).
}
\examples{
#' # Get the Eucalypt data
dat_po <- eucalypt[["po"]]
dat_pa <- eucalypt[["pa"]]

# Set a train and test set
train_po <- dat_po[dat_po$x <= mean(c(dat_po$x, dat_pa$x)), ]
test_po <- dat_po[dat_po$x > mean(c(dat_po$x, dat_pa$x)), ]
train_pa <- dat_pa[dat_pa$x <= mean(c(dat_po$x, dat_pa$x)), ]
test_pa <- dat_pa[dat_pa$x > mean(c(dat_po$x, dat_pa$x)), ]

# Set up a simple 2D grid of basis functions to fit a LGCP model to the data
bfs <- simple_basis(nodes.on.long.edge = 9, data = dat_po)

# Fit an IPP model to the point pattern
m.ipp <- ippm(pres ~ TMP_MIN, data = train_po)

# Fit a combined data model
m.popa <- popa(pres ~ TMP_MIN + D_MAIN_RDS, Y ~ TMP_MIN,
po.data = train_po, pa.data = train_pa, model.type = "ipp")

# Fit presence/absence model
m.pa <- pa(Y ~ TMP_MIN, pa.data = train_pa, model.type = "ipp")

# Fit a LGCP model to the point pattern
m.lgcp_va1 <- po(pres ~ TMP_MIN + D_MAIN_RDS, po.data = train_po,
model.type = "variational", simple.basis = bfs)
# Or
m.lgcp_va2 <- lgcpm(pres ~ TMP_MIN + D_MAIN_RDS, data = train_po,
approx.with = "variational", simple.basis = bfs)

predict(m.ipp, test_po)
predict(m.popa, test_po, process = "intensity")
predict(m.popa, test_pa, process = "abundance")
predict(m.pa, test_pa)
predict(m.lgcp_va1, test_po)
predict(m.lgcp_va2, test_po, dens = "prior")
}
